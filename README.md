# gobuild
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by devflow from github.com/tinywasm/devflow"></a>
<!-- END_SECTION:BADGES_SECTION -->

Thread-safe Go/WASM build handler with sync/async compilation support.

## Installation

```bash
go get github.com/tinywasm/gobuild
```

## Quick Start

Configuration is documented in [config.go](config.go).

```go
// See config.go for full configuration options
config := &Config{
    Command:                    "go",
    MainInputFileRelativePath:  "server/main.go",
    OutName:                    "app",
    Extension:                  ".exe",
    OutFolderRelativePath:      "dist",
    Logger:                     func(msg ...any) { fmt.Println(msg...) },
    Timeout:                    5 * time.Second,
    Env:                        []string{"GOOS=js", "GOARCH=wasm"}, // For WASM compilation
}

compiler := gobuild.New(config)
err := compiler.CompileProgram() // Synchronous
```


## Async Compilation

```go
config.Callback = func(err error) {
    if err != nil {
        log.Printf("Failed: %v", err)
    } else {
        log.Printf("Success!")
    }
}
err := compiler.CompileProgram() // Returns immediately
```

## Thread-Safe Control

```go
// Cancel ongoing compilation
compiler.Cancel()

// Check compilation status
if compiler.IsCompiling() {
    fmt.Println("Compilation in progress...")
}
```


## Methods

- `CompileProgram() error` - Compile to disk (sync/async based on callback)
- `CompileToMemory() ([]byte, error)` - Compile to memory (returns byte slice, sync only)
- `BinarySize() string` - Get human-readable binary size (e.g., "2.1 MB", "10.4 KB")
- `Cancel() error` - Cancel current compilation
- `IsCompiling() bool` - Check if compilation is active
- `MainOutputFileNameWithExtension() string` - Get output filename with extension (e.g., "main.wasm")
- `FinalOutputPath() string` - Get full path to compiled binary (e.g., "web/build/main.wasm")

## In-Memory Compilation

```go
// Compile directly to memory without writing to disk
binary, err := compiler.CompileToMemory()
if err != nil {
    log.Fatal(err)
}

// Get human-readable size (works with both disk and memory compilations)
fmt.Printf("Binary size: %s (%d bytes)\n", compiler.BinarySize(), len(binary))
// Output: Binary size: 2.1 MB (2254340 bytes)
```

## Binary Size Information

```go
// After CompileProgram() or CompileToMemory()
size := compiler.BinarySize()
fmt.Println("Compiled binary:", size) 
// Examples: "10.4 KB", "2.3 MB", "1.5 GB"
// Returns "0.0 KB" if binary is unavailable
```

## Features

- **Thread-safe**: Automatic cancellation of previous compilations
- **Unique temp files**: Prevents conflicts during concurrent builds
- **Context-aware**: Proper cancellation and timeout handling
- **In-memory**: Compile directly to memory slice without disk I/O
- **Size reporting**: Human-readable binary size (KB, MB, GB) for both disk and memory compilations

---
## [Contributing](https://github.com/cdvelop/cdvelop/blob/main/CONTRIBUTING.md)